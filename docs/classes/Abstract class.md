## Abstract class

| Статус    | Ожидание                                                                                      | Реальность                                                           |
| --------- | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| :warning: | Можно наследоваться от абстрактного класса, IDE подсказывает какие методы надо переопределить | В IDE нет подсказок о необходимости переопределить абстрактный метод |

### Пояснения

Опишем простой абстрактный класс на Kotlin-е:

```kotlin
abstract class AbstractClassExample(
    val param1: String
) {
    abstract fun forOverride(): String
}
```

В Swift-коде мы можем сделать наследника этого класса, но IDE не подсказывает нам, что метод `forOverride` нужно переопределить.

```swift
class MySwiftChild : AbstractClassExample {
    
    // Можно не переопределять метод forOverride, код успешно скомпилируется.

}
```

При попытке использовать этот метод приложение упадёт с `NSGenericException`.

[В Objective-C, похоже, нет понятия abstract class](https://stackoverflow.com/questions/1034373/creating-an-abstract-class-in-objective-c), 
и [в Swift - тоже](https://stackoverflow.com/questions/24110396/abstract-classes-in-swift-language). 

В отказе от абстрактных классов есть смысл, что-то вроде "предпочитайте композицию, а не наследование", но после Java 
это может оказаться неудобным.

Самое близкое понятие к абстрактному классу в Swift - это `@protocol`. Поверх протокола можно описать extension-ы, 
можно описывать дефолтные реализации методов. И будет примерно то же самое, что и абстрактный класс.

---
[Оглавление](/README.md)